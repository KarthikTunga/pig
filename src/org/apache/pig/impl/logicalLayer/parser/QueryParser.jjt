/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * JavaCC file
 * This file lists the grammar for PIG Latin.
 * QueryParser program ouputs a ParseTree given a Valid Pig Latin Query
 */
options {
  // Generate non-static functions
  STATIC = false;
  // Case is ignored in keywords
  IGNORE_CASE = true;
}

PARSER_BEGIN(QueryParser)
package org.apache.pig.impl.logicalLayer.parser;
import java.io.*;
import java.util.*;
import org.apache.pig.impl.logicalLayer.*;
import org.apache.pig.impl.logicalLayer.schema.*;
import org.apache.pig.data.DataType;
import org.apache.pig.impl.PigContext;
import org.apache.pig.ExecType;
import org.apache.pig.impl.io.*;
import org.apache.pig.builtin.PigStorage;
import org.apache.pig.impl.builtin.GFAny;
import org.apache.pig.impl.logicalLayer.LogicalPlan;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.pig.impl.plan.MultiMap;
import org.apache.pig.impl.plan.NodeIdGenerator;
import org.apache.pig.impl.plan.OperatorKey;
import org.apache.pig.impl.plan.PlanException;
import org.apache.pig.data.TupleFactory;
import org.apache.pig.data.Tuple;
import org.apache.pig.data.BagFactory;
import org.apache.pig.data.DataBag;
import org.apache.pig.EvalFunc;


public class QueryParser {
	private PigContext pigContext;
	private Map<LogicalOperator, LogicalPlan> aliases;
	private Map<OperatorKey, LogicalOperator> opTable;
	private String scope;
	private NodeIdGenerator nodeIdGen;
	//a map of alias to logical operator for a quick lookup
	private Map<String, LogicalOperator> mapAliasOp;
	private Map<String, ExpressionOperator> defineAliases;
	private static Log log = LogFactory.getLog(QueryParser.class);
	
	private long getNextId() {
		return nodeIdGen.getNextNodeId(scope);
	}

	public QueryParser(InputStream in,
					   PigContext pigContext, 
					   String scope, 
					   Map<LogicalOperator, LogicalPlan> aliases,
					   Map<OperatorKey, LogicalOperator> opTable,
					   Map<String, LogicalOperator> aliasOp,
					   Map<String, ExpressionOperator> defineAliases) {
		this(in);
		this.pigContext = pigContext;
		this.aliases = aliases;
		this.opTable = opTable;
		this.scope = scope;
		this.nodeIdGen = NodeIdGenerator.getGenerator();
		this.mapAliasOp = aliasOp;
		this.defineAliases = defineAliases;
	}

	public class CogroupInput {
		public LogicalOperator op;
		public ArrayList<LogicalPlan> plans;
		public boolean isInner;
	}
	    
    private static String removeQuotes(String str) {
        if (str.startsWith("\'") && str.endsWith("\'"))
            return str.substring(1, str.length() - 1);
        else
            return str;
    }

    public static LogicalPlan generateStorePlan(Map<OperatorKey, LogicalOperator> opTable,
    										    String scope,
                                                LogicalPlan readFrom,
                                                String fileName,
                                                String func,
                                                LogicalOperator input) throws FrontendException {

        if (func == null) {
            func = PigStorage.class.getName();
        }

        fileName = removeQuotes(fileName);

        long storeNodeId = NodeIdGenerator.getGenerator().getNextNodeId(scope);

        LogicalPlan rootPlan = new LogicalPlan();

        LogicalOperator store;
        try {
		store = new LOStore(rootPlan,
							   new OperatorKey(scope, storeNodeId),
                               new FileSpec(fileName, func));
        } catch (IOException ioe) {
            throw new FrontendException(ioe.getMessage());
        }
        
        try {
	        rootPlan.add(store);
	        rootPlan.add(input);
	        rootPlan.connect(input, store);
	        attachPlan(rootPlan, input, readFrom);
        } catch (ParseException pe) {
            throw new FrontendException(pe.getMessage());
        }
				
        return readFrom;
    }

    static String unquote(String s) {
		return s.substring(1, s.length()-1);
	}
	
	static int undollar(String s) {
		return Integer.parseInt(s.substring(1, s.length()));	
	}
	

	String massageFilename(String filename, PigContext pigContext) throws IOException, ParseException {
		if (pigContext.getExecType() != ExecType.LOCAL) {
			if (filename.startsWith(FileLocalizer.LOCAL_PREFIX)) {
					filename = FileLocalizer.hadoopify(filename, pigContext);
			} 
			// Removed check for file existence, that will be handled later by InputOutputFileValidator
		}
		return filename;
	}
	
	LogicalOperator parseCogroup(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{
		
		log.trace("Entering parseCogroup");
		log.debug("LogicalPlan: " + lp);
		
		int n = gis.size();
		log.debug("Number of cogroup inputs = " + n);
		
		ArrayList<LogicalOperator> los = new ArrayList<LogicalOperator>();
		ArrayList<ArrayList<LogicalPlan>> plans = new ArrayList<ArrayList<LogicalPlan>>();
		MultiMap<LogicalOperator, LogicalPlan> groupByPlans = new MultiMap<LogicalOperator, LogicalPlan>();
		//Map<LogicalOperator, LogicalPlan> groupByPlans = new HashMap<LogicalOperator, LogicalPlan>();
		boolean[] isInner = new boolean[n];
		
		int arity = gis.get(0).plans.size();
		
		for (int i = 0; i < n ; i++){
			
			CogroupInput gi = gis.get(i);
			los.add(gi.op);
			ArrayList<LogicalPlan> planList = gi.plans;
			plans.add(gi.plans);
			int numGrpByOps = planList.size();
			log.debug("Number of group by operators = " + numGrpByOps);

			if(arity != numGrpByOps) {
				throw new ParseException("The arity of the group by columns do not match.");
			}
			for(int j = 0; j < numGrpByOps; ++j) {
			    groupByPlans.put(gi.op, planList.get(j));
				for(LogicalOperator root: planList.get(j).getRoots()) {
					log.debug("Cogroup input plan root: " + root);
				}
			}
			isInner[i] = gi.isInner;
		}
		
		LogicalOperator cogroup = new LOCogroup(lp, new OperatorKey(scope, getNextId()), los, groupByPlans, isInner);
		lp.add(cogroup);
		log.debug("Added operator " + cogroup.getClass().getName() + " object " + cogroup + " to the logical plan " + lp);
		
		for(LogicalOperator op: los) {
			lp.connect(op, cogroup);
			log.debug("Connected operator " + op.getClass().getName() + " to " + cogroup.getClass().getName() + " in the logical plan");
		}

		log.trace("Exiting parseCogroup");
		return cogroup;
	}
			
	/**
	 * The join operator is translated to foreach 
	 */
	LogicalOperator rewriteJoin(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{
		
		log.trace("Entering rewriteJoin");
		log.debug("LogicalPlan: " + lp);
		int n = gis.size();
		ArrayList<ExpressionOperator> flattenedColumns = new ArrayList<ExpressionOperator>();
		ArrayList<LogicalPlan> generatePlans = new ArrayList<LogicalPlan>();
		ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
		
		/*
		 * Construct the projection operators required for the generate
		 * Make sure that the operators are flattened
		 */


		LogicalPlan foreachPlan = new LogicalPlan();
		for (int i = 0; i < n; i++) {
			LogicalPlan projectPlan = new LogicalPlan(); 
			LogicalOperator projectInput = gis.get(i).op;
			ExpressionOperator column = new LOProject(projectPlan, new OperatorKey(scope, getNextId()), projectInput, i+1);
			((LOProject)column).setStar(true);
			flattenList.add(true);
			flattenedColumns.add(column);
			(gis.get(i)).isInner = true;
			projectPlan.add(column);
			log.debug("parseCogroup: Added operator " + column.getClass().getName() + " " + column + " to logical plan " + projectPlan);
			generatePlans.add(projectPlan);
		}

		
		//Construct the cogroup operator and add it to the logical plan
		
		LogicalOperator cogroup = parseCogroup(gis, lp);
		lp.add(cogroup);
		log.debug("Added operator " + cogroup.getClass().getName() + " to the logical plan");
		
		
		//Construct the generate operator from the list of projection plans
		//Add the generate operator to the foreach logical plan
		LogicalOperator generate = new LOGenerate(lp, new OperatorKey(scope, getNextId()), generatePlans, flattenList);
		foreachPlan.add(generate);
		log.debug("Added operator " + generate.getClass().getName() + " to the logical plan " + lp);

		
		/*
		 * Construct the foreach operator from the foreach logical plan
		 * Add the foreach operator to the top level logical plan
		 */
		 
		LogicalOperator foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), foreachPlan);
		lp.add(foreach);
		log.debug("Added operator " + foreach.getClass().getName() + " to the logical plan");
		lp.connect(cogroup, foreach);
		log.debug("Connected operator " + cogroup.getClass().getName() + " to opeator " + foreach.getClass().getName() + " in the logical plan " + lp);
		
		log.trace("Exiting rewriteJoin");
		return foreach;
	}

	void assertAtomic(LogicalOperator spec, boolean desiredAtomic) throws ParseException{
		Boolean isAtomic = null;
		if ( spec instanceof LOConst || 
			(spec instanceof LOUserFunc &&
                DataType.isAtomic(DataType.findType(((LOUserFunc)spec).getType()))))
			isAtomic = true;
		else if (spec instanceof LOUserFunc)
			isAtomic = false;
		
		if (isAtomic != null && isAtomic != desiredAtomic){
			if (desiredAtomic)
				throw new ParseException("Atomic field expected but found non-atomic field");
			else
				throw new ParseException("Non-atomic field expected but found atomic field");
		}
	}					

	 void addSplitOutput(LogicalPlan lp, LOSplit splitOp, String alias, LogicalPlan condPlan, int index) throws PlanException{
		LogicalOperator splitOutput = new LOSplitOutput(lp, new OperatorKey(scope, getNextId()), index, condPlan);
		splitOp.addOutput(splitOutput);
		addAlias(alias, splitOutput);
        addLogicalPlan(splitOutput, lp);
		
		lp.add(splitOutput);
		log.debug("Added alias: " + splitOutput.getAlias() + " class: " 
			+ splitOutput.getClass().getName() + " to the logical plan");
			
		lp.connect(splitOp, splitOutput);
		log.debug("Connected " + splitOp.getClass().getName() + " to class: "
			+ splitOutput.getClass().getName() + " in the logical plan");
		
	 }
	 
	 void addAlias(String alias, LogicalOperator lOp) {
	 	mapAliasOp.put(alias, lOp);
	 }
	 
	 LogicalOperator getOp(String alias) {
	 	return mapAliasOp.get(alias);
	 }

	 ExpressionOperator getDefineOp(String alias) {
	 	return defineAliases.get(alias);
	 }
	 
	 //BEGIN
	 //I am maintaining state about the operators that should
	 //serve as the inputs to generate in the foreach logical
	 //plan. I did not want to pass this structure around for
	 //the entire parse tree

	 private boolean insideGenerate = false; //to check if we are parsing inside a generate statement
	 private List<LogicalOperator> generateInputs = new ArrayList<LogicalOperator>();

	boolean insideGenerate() {
		return insideGenerate;
	}

	void setInsideGenerate(boolean b) {
		insideGenerate = b;
	}

	List<LogicalOperator> getGenerateInputs() {
	 	return generateInputs;
	}

	void resetGenerateInputs() {
		generateInputs.clear();
	}

	void addGenerateInput(LogicalOperator op) {
		generateInputs.add(op);
	}

	void resetGenerateState() {
		insideGenerate = false;
		resetGenerateInputs();
	}

	 //END
	
	private static Map<String, Byte> nameToTypeMap = DataType.genNameToTypeMap();

    public void addLogicalPlan(LogicalOperator op, LogicalPlan plan) {
        aliases.put(op, plan);
    }

    public LogicalPlan getLogicalPlan(LogicalOperator op) {
        return aliases.get(op);
    }

    public static void attachPlan(LogicalPlan lp, LogicalOperator root, LogicalPlan rootPlan) throws ParseException {
        log.trace("Entering attachPlan");
        lp.add(root);
        log.debug("Added operator " + root + " to the logical plan " + lp);
        if(null == rootPlan.getPredecessors(root)) {
            log.trace("Exiting attachPlan");
            return;
        }
        for(LogicalOperator rootPred: rootPlan.getPredecessors(root)) {
            attachPlan(lp, rootPred, rootPlan);
            try {
                lp.connect(rootPred, root);
                log.debug("Connected operator " + rootPred + " to " + root + " in the logical plan " + lp);
            } catch (FrontendException fee) {
                throw new ParseException(fee.getMessage());
            }
        }
        log.trace("Exiting attachPlan");
    }

}

	
PARSER_END(QueryParser)

// Skip all the new lines, tabs and spaces
SKIP : { " " |	"\r" |	"\t" |	"\n" }

// Skip comments(single line and multiline)
SKIP : {
   <"--"(~["\r","\n"])*>
|  <"/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}
// Comparison operators that can be used in a filter:
TOKEN : { <#STRFILTEROP : "eq" | "gt" | "lt" | "gte" | "lte" | "neq" > }
TOKEN : { <#NUMFILTEROP : "==" | "<" | "<=" | ">" | ">=" | "!=" > }
TOKEN : { <FILTEROP : <STRFILTEROP> | <NUMFILTEROP>  > }

// List all the keywords in the language
TOKEN : { <LOAD : "load"> }
TOKEN : { <FILTER : "filter"> }
TOKEN : { <FOREACH : "foreach"> }
TOKEN : { <MATCHES : "matches"> }
TOKEN : { <ORDER : "order"> }
TOKEN : { <ARRANGE : "arrange"> }
TOKEN : { <DISTINCT : "distinct"> }
TOKEN : { <COGROUP : "cogroup"> }
TOKEN : { <JOIN : "join"> }
TOKEN : { <CROSS : "cross"> }
TOKEN : { <UNION : "union"> }
TOKEN : { <SPLIT : "split"> }
TOKEN : { <INTO : "into"> }
TOKEN : { <IF : "if"> }
TOKEN : { <ALL : "all"> }
TOKEN : { <ANY : "any"> }
TOKEN : { <AS : "as">	}
TOKEN : { <BY : "by">	}
TOKEN : { <USING : "using"> }
TOKEN : { <INNER : "inner"> }
TOKEN : { <OUTER : "outer"> }
TOKEN : { <STAR : "*"> 		}
TOKEN : { <PARALLEL : "parallel"> }
TOKEN : { <GROUP : "group"> }
TOKEN : { <AND : "and"> }
TOKEN : { <OR : "or"> }
TOKEN : { <NOT : "not"> }
TOKEN : { <GENERATE : "generate"> }
TOKEN : { <FLATTEN : "flatten"> }
TOKEN : { <EVAL : "eval"> }
TOKEN : { <ASC : "asc"> }
TOKEN : { <DESC : "desc"> }
TOKEN : { <INT : "int"> }
TOKEN : { <LONG : "long"> }
TOKEN : { <FLOAT : "float"> }
TOKEN : { <DOUBLE : "double"> }
TOKEN : { <CHARARRAY : "chararray"> }
TOKEN : { <BYTEARRAY : "bytearray"> }
TOKEN : { <BAG : "bag"> }
TOKEN : { <TUPLE : "tuple"> }
TOKEN : { <MAP : "map"> }
TOKEN : { <DEFINE : "define"> }
TOKEN : { <IS : "is"> }
TOKEN : { <NULL : "null"> }

TOKEN:
{
 	<#LETTER : ["a"-"z", "A"-"Z"] >
|	<#DIGIT : ["0"-"9"] >
|   <#SPECIALCHAR : ["_"] >
|   <#FSSPECIALCHAR: ["-", ":", "/"]>
|	<IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> | <SPECIALCHAR> | "::")* >
}
// Define Numeric Constants
TOKEN :
{
//	< NUMBER: <INTEGER> | <LONGINTEGER> | <DOUBLENUMBER> | <FLOATNUMBER> >
 	< #FLOATINGPOINT: <INTEGER> ( "." <INTEGER> )? | "." <INTEGER> >
| 	< INTEGER: ( <DIGIT> )+ >
| 	< LONGINTEGER: <INTEGER> (["l","L"])? >
|   < DOUBLENUMBER: <FLOATINGPOINT> ( ["e","E"] ([ "-","+"])? <FLOATINGPOINT> )?>
|   < FLOATNUMBER: <DOUBLENUMBER> (["f","F"])? >
}

TOKEN : { <QUOTEDSTRING : "'" (~["'"])* "'"> }
// Pig has special variables starting with $
TOKEN : { <DOLLARVAR : "$" <INTEGER> > }

// Parse is the Starting function.
LogicalPlan Parse() : 
{
	LogicalOperator root = null; 
	Token t1; 
	LogicalPlan lp = new LogicalPlan();
	log.trace("Entering Parse");
}
{
	(
	LOOKAHEAD(2)
	(t1 = <IDENTIFIER> "=" root = Expr(lp) ";" {root.setAlias(t1.image); addAlias(t1.image, root);})
|	(root = Expr(lp) ";")
|	(<SPLIT> root = SplitClause(lp) ";")
|	(<DEFINE> DefineClause(lp) ";")
	)
	{ 
		if(null != root) {
            log.debug("Adding " + root.getAlias() + " " + root + " to the lookup table " + aliases);
            addLogicalPlan(root, lp);
			log.debug("Root: " + root.getClass().getName() + " schema: " + root.getSchema());
		}

        ArrayList<LogicalOperator> roots = new ArrayList<LogicalOperator>(lp.getRoots().size());
        for(LogicalOperator op: lp.getRoots()) {
            roots.add(op);
        }
        
        for(LogicalOperator op: roots) {
            //At this point we have a logical plan for the pig statement
            //In order to construct the entire logical plan we need to traverse
            //each root and get the logical plan it belongs to. From each of those
            //plans we need the predecessors of the root of the current logical plan
            //and so on. This is a computationally intensive operatton but should
            //be fine as its restricted to the parser

            LogicalPlan rootPlan = aliases.get(op);
            if(null != rootPlan) {
                attachPlan(lp, op, rootPlan);
            }
        }
		
		log.trace("Exiting Parse");
		return lp; 
	}
}

LogicalOperator SplitClause(LogicalPlan lp):
{
	LogicalOperator input; 
	ExpressionOperator cond; 
	Token alias; 
	LOSplit splitOp; 
	int index = 0; 
	LogicalPlan condPlan; 
	log.trace("Entering SplitClause");
}
{
	(
	input = NestedExpr(lp) <INTO> 
	{
		splitOp = new LOSplit(lp, input.getOperatorKey(), new ArrayList<LogicalOperator>());
		lp.add(splitOp);
		log.debug("Adding operator " + splitOp.getClass().getName() + " to the logical plan");		
        lp.connect(input, splitOp);
		log.debug("Connected alias: " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + splitOp.getClass().getName());
	}
	alias = <IDENTIFIER> <IF> cond = PCond(input.getSchema(), null, condPlan = new LogicalPlan(), input) 
	{
		addSplitOutput(lp, splitOp, alias.image, condPlan, index);
		++index;
		log.debug("Added splitoutput");
	}
	(
	"," alias = <IDENTIFIER> <IF> cond = PCond(input.getSchema(), null, condPlan = new LogicalPlan(), input)
	{
		addSplitOutput(lp, splitOp, alias.image, condPlan, index);
		++index;
		log.debug("Added splitoutput");
	}
	)+
	)
	{log.trace("Exiting SplitClause"); return splitOp;}
} 

void DefineClause(LogicalPlan lp) :
{
	Token t;
	ExpressionOperator exOp;
	log.trace("Entering DefineClause");
}
{
	(t = <IDENTIFIER> "=" exOp = FuncDeclareSpec(lp))
	{
		defineAliases.put(t.image, exOp);
		log.trace("Exiting DefineClause");
	}
}


LogicalOperator Expr(LogicalPlan lp) : 
{
	LogicalOperator op; 
	Schema schema; 
	log.trace("Entering Expr");
}
{
	(
	( op = NestedExpr(lp) [ <AS> "(" schema = TupleSchema() ")" {op.setSchema(schema);} ] )
|	op = BaseExpr(lp)
	)
	{log.trace("Exiting Expr"); return op;}
}	

LogicalOperator NestedExpr(LogicalPlan lp) : 
{
	LogicalOperator op; 
	ExpressionOperator eOp;
	Map<String, LogicalOperator> specs = null; 
	log.trace("Entering NestedExpr");
}
{
	(
	(op = Alias(lp))
|	LOOKAHEAD(2) ( "(" op = NestedExpr(lp) ")" )
|	( "(" op = BaseExpr(lp) ")" )
	)
	{log.trace("Exiting NestedExpr"); return op;}
}

// A reference to an alias
LogicalOperator Alias(LogicalPlan lp) : 
{
	Token t1; 
	LogicalOperator op; 
	log.trace("Entering Alias");
}
{
	t1 = <IDENTIFIER> 
	{
		LogicalOperator aliasOp;
		String alias = t1.image;
		
		aliasOp = getOp(alias);
		if (aliasOp == null) {
			throw new ParseException("Unrecognized alias " + alias);
		}
		addAlias(alias, aliasOp);
		log.debug("Added " + alias + " to aliasOp");
		
		lp.add(aliasOp);
		log.debug("Added operator: " + aliasOp.getClass().getName() + " to the logical plan " + lp);
		log.trace("Exiting Alias");
		return aliasOp;
	}
}

LogicalOperator BaseExpr(LogicalPlan lp) : 
{
	LogicalOperator op; 
	Schema schema; 
	Token t1, t2; 
	Schema.FieldSchema fs; 
	log.trace("Entering BaseExpr");
}
{
	(
	(
	(<LOAD> op = LoadClause(lp) [<AS> (LOOKAHEAD(2) "(" schema = TupleSchema() ")" {op.setSchema(schema);log.debug("Load as schema()");schema.printAliases();} | fs = AtomSchema() {schema = new Schema(fs); op.setSchema(schema); log.debug("Load as atomschema()");schema.printAliases();}) ])
|	((<GROUP> | <COGROUP>) op = CogroupClause(lp))
|	(<FILTER> op = FilterClause(lp))
|   (<ORDER> op = OrderClause(lp))
|	(<DISTINCT> op = NestedExpr(lp) 
	{
		LogicalOperator distinct = new LODistinct(lp, new OperatorKey(scope, getNextId()), op); 
		lp.add(distinct);
		log.debug("Added operator: " + distinct.getClass().getName() + " to the logical plan"); 
		lp.connect(op, distinct);
		log.debug("Connected alias: " + op.getAlias() + " operator " + op.getClass().getName() + " to operator " + distinct.getClass().getName());
	})
|	(<CROSS> op = CrossClause(lp))
|   (<JOIN> op = JoinClause(lp))
|	(<UNION> op = UnionClause(lp))
|	(<FOREACH> op = ForEachClause(lp))
	)
    [<PARALLEL> t2=<INTEGER> { op.setRequestedParallelism(Integer.parseInt(t2.image));} ]
	)	
	{log.trace("Exiting BaseExpr"); return op;}
}

LogicalOperator LoadClause(LogicalPlan lp) : 
{
	Token t1, t2; 
	String filename; 
	String funcName,funcArgs, funcSpec=null; 
	LOLoad lo=null; 
	log.trace("Entering LoadClause");
}
{
	(	filename = FileName()
		(
		<USING>  funcName = QualifiedFunction() "(" funcArgs = StringList() ")"
		{
			funcSpec = funcName + "(" + funcArgs + ")";
			log.debug("LoadClause: funcSpec = + funcSpec");
		}
		)?
	)
	{
		if (funcSpec == null){
			funcSpec = PigStorage.class.getName() + "()";
		}
		 
		lo = new LOLoad(lp, new OperatorKey(scope, getNextId()), new FileSpec(massageFilename(filename, pigContext), funcSpec), null);
		lp.add(lo);
		log.debug("Added operator " + lo.getClass().getName() + " to the logical plan");	
		
		log.trace("Exiting LoadClause");
		return lo;
	} 
}    

String StringList() : 
{
	StringBuilder sb = new StringBuilder(); 
	Token t;
}
{
	(
	(
	t = <QUOTEDSTRING> {sb.append(t.image);}
	( "," t = <QUOTEDSTRING> {sb.append(",");sb.append(t.image);} )*
	)
	| {}
	)
	{log.debug("StringList: " + sb.toString()); return sb.toString();}
}

String FileName(): 
{
	Token t;
}
{
	t = <QUOTEDSTRING> 
	{log.debug("FileName: " + unquote(t.image)); return unquote(t.image);}
}

LogicalOperator FilterClause(LogicalPlan lp):
{
	ExpressionOperator cond; LogicalOperator input; 
	LogicalPlan conditionPlan = new LogicalPlan();
	log.trace("Entering FilterClause");
}
{
	(
	input = NestedExpr(lp) {log.debug("Filter input: " + input);}	
	 <BY> cond = PCond(input.getSchema(),null,conditionPlan,input)
	 )
	{
		LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan, input);
		addAlias(input.getAlias(), input);
		lp.add(filter);
		log.debug("Added operator " + filter.getClass().getName() + " to the logical plan");
		
		lp.connect(input, filter);
		log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + filter.getClass().getName() +" in the logical plan");

		log.trace("Exiting FilterClause");
		return filter;
	}
}


ExpressionOperator PCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator cond = null; 
	log.trace("Entering PCond"); 
	log.debug("PCond Input: " + input);
}
{
	cond = POrCond(over,specs,lp, input)
	{log.trace("Exiting PCond"); return cond;}
}

ExpressionOperator POrCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator lhsCond, rhsCond; 
	log.trace("Entering POrCond"); 
	log.debug("POrCond Input: " + input);
}
{
	(
	lhsCond = PAndCond(over,specs,lp,input)
	(
		<OR> rhsCond = PAndCond(over,specs,lp,input)
		{
			ExpressionOperator exprOp = new LOOr(lp, new OperatorKey(scope, getNextId()), lhsCond, rhsCond);
			lp.add(exprOp);
			log.debug("POrCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
			lp.connect(lhsCond, exprOp);
			log.debug("POrCond: Connected operator " + lhsCond.getClass().getName() + " " + lhsCond + " to " + exprOp + " logical plan " + lp);
			lp.connect(rhsCond, exprOp);
			log.debug("POrCond: Connected operator " + rhsCond.getClass().getName() + " " + rhsCond + " to " + exprOp + " logical plan " + lp);
			lhsCond = exprOp;
		}
	)* 
	)
	{
			log.trace("Exiting POrCond");
			return lhsCond;
	}
}
	
ExpressionOperator PAndCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator lhsCond, rhsCond; 
	log.trace("Entering PAndCond"); 
	log.debug("PAndCond Input: " + input);
}
{
	(
	lhsCond = PUnaryCond(over,specs,lp,input) 
	(
		<AND> rhsCond = PUnaryCond(over,specs,lp,input)
		{
			ExpressionOperator exprOp = new LOAnd(lp, new OperatorKey(scope, getNextId()), lhsCond, rhsCond);
			lp.add(exprOp);
			log.debug("PAndCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
			lp.connect(lhsCond, exprOp);
			log.debug("PAndCond: Connected operator " + lhsCond.getClass().getName() + " " + lhsCond + " to " + exprOp + " logical plan " + lp);
			lp.connect(rhsCond, exprOp);
			log.debug("PAndCond: Connected operator " + rhsCond.getClass().getName() + " " + rhsCond + " to " + exprOp + " logical plan " + lp);
			lhsCond = exprOp;
		}
	)*
	)
	{
			log.trace("Exiting PAndCond");
			return lhsCond;
	}	
}

ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator cond = null; 
	ExpressionOperator lhs, rhs; 
	Token t1; 
	String funcName; 
	List<ExpressionOperator> args;
	log.trace("Entering PUnaryCond");
}
{
	(
	LOOKAHEAD("(" PCond(over,specs,lp,input) ")")
	("(" cond = PCond(over,specs,lp,input) ")")
|	LOOKAHEAD(InfixExpr(over,specs,lp,input) <FILTEROP>) 
	(lhs=InfixExpr(over,specs,lp,input) t1=<FILTEROP> rhs=InfixExpr(over,specs,lp,input) 
	{
		//the long switch case to instantiate the right operator
		//I have the long switch case from CompCond
		String op = t1.image;
		op = op.toLowerCase();
		
		char op1 = op.charAt(0);
        char op2 = op.length() >= 2 ? op.charAt(1) : '0';
        char op3 = op.length() == 3 ? op.charAt(2) : '0';
        
        switch (op1) {
            // numeric ops first
        case '=':
            if (op2 == '=') {
                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                throw new ParseException("Internal error: Invalid filter operator: " + op);
            }
            break;
        case '<':
            if (op2 == '=') {
                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            }
            break;
        case '>':
            if (op2 == '=') {
                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            }
            break;
        case '!':
            if (op2 == '=') {
                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                throw new ParseException("Internal error: Invalid filter operator: " + op);
            }
            break;
            // now string ops
        case 'e':
            if (op2 == 'q') {
                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                throw new ParseException("Internal error: Invalid filter operator: " + op);
            }
            break;
        case 'l':
            if (op2 == 't' && op3 == 'e') {
                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            }
            break;
        case 'g':
            if (op2 == 't' && op3 == 'e') {
                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            }
            break;
        case 'n':
            if (op2 == 'e' && op3 == 'q') {
                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
            } else {
                throw new ParseException("Internal error: Invalid filter operator: " + op);
            }
            break;
        default:
            throw new ParseException("Internal error: Invalid filter operator: " + op);
        }
        
        lp.add(cond);
		log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
		lp.connect(lhs, cond);
		log.debug("PUnaryCond: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + cond + " logical plan " + lp);
		lp.connect(rhs, cond);
		log.debug("PUnaryCond: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + cond + " logical plan " + lp);
	}
	)
|	LOOKAHEAD(InfixExpr(over,specs,lp,input) <MATCHES>) 
		(lhs=InfixExpr(over,specs,lp,input) <MATCHES> t1=<QUOTEDSTRING> 
			{
				cond = new LORegexp(lp, new OperatorKey(scope, getNextId()), lhs, unquote(t1.image)); 
				lp.add(cond); 
				log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
				lp.connect(lhs, cond);
				log.debug("PUnaryCond: Connected operator " + cond.getClass().getName() + " " + cond + " to " + lhs + " logical plan " + lp);
			}
		)
|	LOOKAHEAD(EvalFunction() "(") 
		(funcName=EvalFunction() "(" args=EvalArgs(over,specs,lp,input) ")" 
			{
				cond = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcName, args, DataType.BOOLEAN);
				lp.add(cond);
				log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
				for(ExpressionOperator exprOp: args) {
					lp.connect(exprOp, cond);
					log.debug("PUnaryCond: Added operator " + exprOp.getClass().getName() + " " + cond + " to logical plan " + lp);
				}
			}
		)
|	cond = PNullCond(over,specs,lp,input)
|	cond = PNotCond(over,specs,lp,input)

	)
	{log.trace("Exiting PUnaryCond"); return cond;}
}

ExpressionOperator PNotCond(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) : 
{
	ExpressionOperator c1;
	log.trace("Entering PNotCond");
}
{
	<NOT> c1=PUnaryCond(over,specs,lp,input)
	{
		ExpressionOperator eOp = new LONot(lp, new OperatorKey(scope, getNextId()), c1);
		lp.add(eOp);
		log.debug("PNotCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
		lp.connect(c1, eOp);
		log.debug("PNotCond: Connected operator " + eOp.getClass().getName() + " " + eOp + " to " + c1 + " logical plan " + lp);
		log.trace("Exiting PNotCond");
		return eOp;
	}
}

ExpressionOperator PNullCond(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) : 
{
	ExpressionOperator c1;
    boolean not = false;
	log.trace("Entering PNullCond");
}
{
	c1=InfixExpr(over,specs,lp,input) <IS> [<NOT> {not = true;}] <NULL>
	{
		ExpressionOperator eOp = new LOIsNull(lp, new OperatorKey(scope, getNextId()), c1);
		lp.add(eOp);
		log.debug("PNullCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
		lp.connect(c1, eOp);
		log.debug("PNullCond: Connected operator " + eOp.getClass().getName() + " " + eOp + " to " + c1 + " logical plan " + lp);
        ExpressionOperator notNull = null;
        if (not) {
            notNull = new LONot(lp, new OperatorKey(scope, getNextId()), eOp); 
            lp.add(notNull);
		    log.debug("PNullCond: Added operator " + notNull.getClass().getName() + " " + notNull + " to logical plan " + lp);
            lp.connect(eOp, notNull);
		    log.debug("PNullCond: Connected operator " + notNull.getClass().getName() + " " + notNull + " to " + eOp + " logical plan " + lp);
            eOp = notNull;
        }
		log.trace("Exiting PNullCond");
		return eOp;
	}
}

LogicalOperator CogroupClause(LogicalPlan lp) : 
{
	CogroupInput gi; 
	ArrayList<CogroupInput> gis = new ArrayList<CogroupInput>(); 
	LogicalOperator cogroup; 
	log.trace("Entering CoGroupClause");
}
{

	(gi = GroupItem(lp) { gis.add(gi); }
	("," gi = GroupItem(lp) { gis.add(gi); })*)
	{
		cogroup = parseCogroup(gis, lp);
		log.trace("Exiting CoGroupClause");
		return cogroup;		
	}

}

CogroupInput GroupItem(LogicalPlan lp) : 
{
	ExpressionOperator es; 
	LogicalOperator cgOp; 
	boolean isInner = false; 
	ArrayList<LogicalPlan> listPlans = new ArrayList<LogicalPlan>(); 
	LogicalPlan groupByPlan;
	ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
	log.trace("Entering GroupItem");
	log.debug("LogicalPlan: " + lp);
}
{
	(
		cgOp = NestedExpr(lp)
		(
			( <BY> 
				( 
					LOOKAHEAD ( "(" FlattenedGenerateItemList(cgOp.getSchema(), null, groupByPlan, cgOp) ")" )
					( "(" es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList) 
						{listPlans.add(groupByPlan);}
						(
							"," es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList) 
							{listPlans.add(groupByPlan);}
						)*
						")" 
					)
				|	(
						es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList) 
						{listPlans.add(groupByPlan);}
					)
				)
			)	
		|	<ALL> {
					es = new LOConst(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), "all"); 
					groupByPlan.add(es);
					log.debug("GroupItem: Added operator " + es.getClass().getName() + " " + es + " to logical plan " + groupByPlan);
					listPlans.add(groupByPlan);
			}
		|	<ANY> {
					es = new LOUserFunc(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), GFAny.class.getName(), null, DataType.INTEGER); 
					groupByPlan.add(es);
					log.debug("GroupItem: Added operator " + es.getClass().getName() + " " + es + " to logical plan " + groupByPlan);
					listPlans.add(groupByPlan);
			}
		)
		[<INNER> {isInner = true;} | <OUTER>]
	)
	{
		CogroupInput cogroupInput = new CogroupInput(); 

		cogroupInput.plans = listPlans;
		cogroupInput.op = cgOp;
		cogroupInput.isInner = isInner;
		
		log.trace("Exiting GroupItem");		
		return cogroupInput;
    }
}

LogicalOperator OrderClause(LogicalPlan lp) : 
{
	LogicalOperator op; 
	ExpressionOperator col; 
	boolean star = false; 
	ArrayList<ExpressionOperator> sortCols = new ArrayList<ExpressionOperator>(); 
	ArrayList<LogicalPlan> sortColPlans = new ArrayList<LogicalPlan>(); 
	ArrayList<Boolean> ascOrder = new ArrayList<Boolean>(); 
	boolean asc = true; 
	String funcName = null; 
	log.trace("Entering OrderClause");
}
{
	(
	op = NestedExpr(lp) <BY> 
	(
	    ( 
		(
		col = SortCol(op.getSchema(), lp, op, ascOrder, sortColPlans) 
		("," col = SortCol(op.getSchema(), lp, op, ascOrder, sortColPlans))*		
		)
	)
	|	<STAR> {star = true;} [<ASC> | <DESC> {asc = false;}] 
		{
			if(asc) {
				ascOrder.add(true);
			} else {	
				ascOrder.add(false);
			}
		}	
	)
    (
        <USING>  funcName = QualifiedFunction()
    )?

	)
	{
		LOSort sort = new LOSort(lp, new OperatorKey(scope, getNextId()), op, sortColPlans, ascOrder, funcName);
		sort.setStar(star);
		lp.add(sort);
		log.debug("Added operator " + sort.getClass().getName() + " to the logical plan");
		
		lp.connect(op, sort);
		log.debug("Connecting sort input alias " + op.getAlias() + " operator " + op.getClass().getName() + " to operator " + sort.getClass().getName() + " in the logical plan");
		
		log.trace("Exiting OrderClause");
		return sort;		
	}
}


ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, ArrayList<Boolean> ascOrder, ArrayList<LogicalPlan> sortColPlans) : 
{
	ExpressionOperator col; 
	boolean asc = true; 
	LogicalPlan sortColPlan = new LogicalPlan(); 
	log.trace("Entering SortCol");}
{
	(
		col = ColOrSpec(op.getSchema(), null, sortColPlan, op) [<ASC> | <DESC> {asc = false;}]
		{
			if(asc) {
				log.debug("Ascending");
				ascOrder.add(true);
			} else {
				log.debug("Descending");	
				ascOrder.add(false);
			}
			sortColPlans.add(sortColPlan);
		}
		|
		( 
			"(" col = ColOrSpec(op.getSchema(), null, sortColPlan, op) ")" [<ASC> | <DESC> {asc = false;}]
			{
				if(asc) {
					log.debug("Ascending");
					ascOrder.add(true);
				} else {
					log.debug("Descending");	
					ascOrder.add(false);
				}
				sortColPlans.add(sortColPlan);
			}
		)
	)
	{
		log.trace("Exiting SortCol");
		return col;
	}	
}

int ColName(Schema over) : 
{
	Token t; 
	log.trace("Entering ColName");
}
{
	(
	t = <DOLLARVAR> {return undollar(t.image);}
	|
	t = <IDENTIFIER> 
	{	int i;
		
		if ( over == null ||  (i = over.getPosition(t.image)) == -1) {
			throw new ParseException("Invalid alias: " + t.image + " in " + over);
		} 
		
		log.trace("Exiting ColName");
		return i;
	}
	)
}		

LogicalOperator CrossClause(LogicalPlan lp) : 
{
	LogicalOperator op; 
	ArrayList<LogicalOperator> inputs = new ArrayList<LogicalOperator>(); 
	log.trace("Entering CrossClause");
}
{
	(
	op = NestedExpr(lp) { inputs.add(op); }
	("," op = NestedExpr(lp) { inputs.add(op); })*
	)
	{
		LogicalOperator cross = new LOCross(lp, new OperatorKey(scope, getNextId()), inputs);
		lp.add(cross);
		log.debug("Added operator " + cross.getClass().getName() + " to the logical plan");
		
		for (LogicalOperator lop: inputs) {
				lp.connect(lop, cross);	
				log.debug("Connected operator " + lop.getClass().getName() + " " + lop + " to " + cross + " logical plan " + lp);
		}
		log.debug("Connected cross inputs to the cross operator");
		
		log.trace("Exiting CrossClause");
		return cross;
	}
}

LogicalOperator JoinClause(LogicalPlan lp) : 
{
	CogroupInput gi; 
	ArrayList<CogroupInput> gis = new ArrayList<CogroupInput>(); 
	log.trace("Entering JoinClause");
	log.debug("LogicalPlan: " + lp);
}
{
	(gi = GroupItem(lp) { gis.add(gi); }
	("," gi = GroupItem(lp) { gis.add(gi); })*)
	{log.trace("Exiting JoinClause"); return rewriteJoin(gis, lp);}
	
}

LogicalOperator UnionClause(LogicalPlan lp) : 
{
	LogicalOperator op;
	ArrayList<LogicalOperator> inputs = new ArrayList<LogicalOperator>(); 
	log.trace("Entering UnionClause");
}
{
	(op = NestedExpr(lp){inputs.add(op);} 
	("," op = NestedExpr(lp) {inputs.add(op);})*)
	{
		LogicalOperator union = new LOUnion(lp, new OperatorKey(scope, getNextId()), inputs);
		lp.add(union);
		log.debug("Added operator " + union.getClass().getName() + " to the logical plan");
		
		for (LogicalOperator lop: inputs) {
			lp.connect(lop, union);
			log.debug("Connected union input operator " + lop.getClass().getName() + " to operator " + lop.getClass().getName() + " in the logical plan");
		}		
		
		log.trace("Exiting UnionClause");
		return union;
	}
}


LogicalOperator ForEachClause(LogicalPlan lp) : 
{
	ArrayList<LogicalOperator> specList = new ArrayList<LogicalOperator>(); 
	LogicalOperator input, foreach; 
	LogicalPlan foreachPlan = new LogicalPlan();
	log.trace("Entering ForEachClause");
}
{
	(
	input = NestedExpr(lp)
	specList = NestedBlock(input.getSchema(), specList, foreachPlan, input)
	)
	{
		foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), foreachPlan);
		try {
			lp.add(foreach);
			log.debug("Added operator " + foreach.getClass().getName() + " to the logical plan");
		
			lp.connect(input, foreach);
			log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " object " + input + " to operator " + foreach.getClass().getName() + " in the logical plan");
		} catch (PlanException planException) {
			ParseException parseException = new ParseException(planException.getMessage());
			throw parseException;
		}
		
		log.trace("Exiting ForEachClause");
		return foreach;
	}
}

ArrayList<LogicalOperator> NestedBlock(Schema over, ArrayList<LogicalOperator> specList, LogicalPlan lp, LogicalOperator input):
{
	LogicalOperator spec; 
	Map<String, LogicalOperator> specs = new HashMap<String, LogicalOperator>(); 
	log.trace("Entering NestedBlock");
}
{
	(
	spec = GenerateStatement(over,specs, lp, input) {specList.add(spec);}
|	("{" (NestedCommand(over,specs,specList, lp, input) ";")* spec = GenerateStatement(over,specs,lp,input)	 ";" "}")
	{specList.add(spec);}
	)
	{log.trace("Exiting NestedBlock"); return specList;}
}

void NestedCommand(Schema over, Map<String, LogicalOperator> specs, List<LogicalOperator> specList, LogicalPlan lp, LogicalOperator input):
{
	Token t; 
	LogicalOperator item; 
	ExpressionOperator eOp = null; 
	log.trace("Entering NestedCommand");
}
{
	(
	t = <IDENTIFIER> "="
	(
	eOp = InfixExpr(over,specs,lp,input) 
	{
		item = eOp;
		lp.add(eOp);
		log.debug("Added operator " + eOp.getClass().getName() + " " + eOp + " to the logical plan " + lp);
	}
|	item = NestedFilter(over,specs,lp, input)	 
| 	item = NestedSortOrArrange(over,specs,lp, input)
|	item = NestedDistinct(over,specs,lp, input)	
	)
	)	
	{
		String alias = t.image;
		item.setAlias(alias);
		specs.put(alias,item);
		log.debug("Added " + alias + " to the specs map");
		specList.add(item);
		log.debug("Added " + alias + " to the specList");
		
		log.trace("Exiting NestedCommand");
	}
}		

LogicalOperator NestedFilter(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	ExpressionOperator cond; 
	Schema subSchema = null; 
	ExpressionOperator eOp; 
	LogicalPlan conditionPlan = new LogicalPlan(); 
	log.trace("Entering NestedFilter");
}
{
	(
	<FILTER>  eOp = BaseEvalSpec(over, specs, lp, input)
	{subSchema = eOp.getSchema();}
	<BY> cond = PCond(subSchema,null,conditionPlan,input)
	)
	{ 
		lp.add(eOp);
		log.debug("Added " + eOp.getAlias() + " to the logical plan");
		LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan, eOp);
		lp.add(filter);
		log.debug("Added nested filter operator " + filter.getClass().getName() + " to the logical plan");
		
		lp.connect(eOp, filter);
		log.debug("Connected the filter input to the filter");
		
		log.trace("Exiting NestedFilter");
		return filter;  
	}

}

LogicalOperator NestedSortOrArrange(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	ExpressionOperator col;	
	boolean star = false; 
	ArrayList<LogicalPlan> sortColPlans = new ArrayList<LogicalPlan>(); 
	ArrayList<Boolean> ascOrder = new ArrayList<Boolean>(); 
	String funcName = null; 
	ExpressionOperator eOp;
	Token t; 
	boolean asc = true; 
	log.trace("Entering NestedSortOrArrange");}
{
	(
	( t = <ORDER> | t = <ARRANGE> )
	(
		eOp = BaseEvalSpec(over, specs, lp, input)
		{
			try{
				eOp.getSchema();
			}catch(FrontendException fe) {
				ParseException pe = new ParseException(fe.getMessage());
				throw pe;
			}
			log.debug("Before BY");
		}		
	)
	<BY> 
	(
		(
			col = SortCol(eOp.getSchema(), lp, eOp, ascOrder, sortColPlans) 
			("," col = SortCol(eOp.getSchema(), lp, eOp, ascOrder, sortColPlans) )*		
			
		)
		| <STAR> {star = true;} [<ASC> | <DESC> {asc = false;}] 
			{
				if(asc) {
					ascOrder.add(true);
				} else {	
					ascOrder.add(false);
				}
			}		
	)     
    (
        <USING>  funcName = QualifiedFunction()
    )?
	)
	{	
		log.debug("Before creating LOSort");
		LOSort sort = new LOSort(lp, new OperatorKey(scope, getNextId()), eOp, sortColPlans, ascOrder, funcName);
		sort.setStar(star);
		log.debug("After creating LOSort");
		try {
			lp.add(eOp);
			log.debug("Added " + eOp +  " " + eOp.getClass().getName() + " to the logical plan");
			lp.add(sort);
			log.debug("Added operator " + sort.getClass().getName() + " to the logical plan");
		
			lp.connect(eOp, sort);
			log.debug("Connected alias " + eOp.getAlias() + " operator " + eOp.getClass().getName() + " to operator " + sort.getClass().getName() + " the logical plan");
		} catch (PlanException planException) {
			ParseException parseException = new ParseException(planException.getMessage());
			throw parseException;
		}
		
		log.trace("Exiting NestedSortOrArrange");
		return sort;		
	}
}
	
LogicalOperator NestedDistinct(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	Token t; 
	ExpressionOperator eOp; 
	log.trace("Entering NestedDistinct");
}
{
	(
	<DISTINCT> eOp = BaseEvalSpec(over, specs, lp, input)
	)
	{ 
		lp.add(eOp);
		log.debug("Added " + eOp.getAlias() + " to the logical plan");
		LogicalOperator distinct = new LODistinct(lp, new OperatorKey(scope, getNextId()), eOp);
		lp.add(distinct);
		log.debug("Added operator " + distinct.getClass().getName() + " to the logical plan");
		
		lp.connect(eOp, distinct);
		log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + distinct.getClass().getName() + " in the logical plan");
		
		log.trace("Exiting NestedDistinct");
		return distinct; 
	}
}
	
	
LogicalOperator GenerateStatement(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	LogicalOperator spec = null; 
	Schema schema;
	setInsideGenerate(true);
	log.trace("Entering GenerateStatement");
}
{
	(
	<GENERATE>
	spec = FlattenedGenerateItemList(over,specs,lp,input)
	)
	{
		log.debug("Connecting generate inputs");
		for(LogicalOperator op: getGenerateInputs()) {
			lp.connect(op, spec);
			log.debug("Connected operator: " + op.getClass().getName() + " to " + op + " " + spec + " in logical plan " + lp);
		}
		resetGenerateState();
		log.trace("Exiting GenerateStatement");
		return spec;
	}
}

LogicalOperator FlattenedGenerateItemList(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	ArrayList<LogicalPlan> generatePlans = new ArrayList<LogicalPlan>(); 
	ArrayList<Boolean> flattenList = new ArrayList<Boolean>(); 
	ExpressionOperator item;
	LogicalPlan generatePlan;
	log.trace("Entering FlattenedGenerateItemList");
}
{
	(
	item = FlattenedGenerateItem(over, specs, generatePlan = new LogicalPlan(), input, flattenList) {generatePlans.add(generatePlan);}
	("," item = FlattenedGenerateItem(over, specs, generatePlan = new LogicalPlan(), input, flattenList) {generatePlans.add(generatePlan);})*
	
	)
	{
		LogicalOperator generate = new LOGenerate(lp, new OperatorKey(scope, getNextId()), generatePlans, flattenList);
		lp.add(generate);
		log.debug("Added operator " + generate.getClass().getName() + " to the logical plan");
		log.trace("Exiting FlattenedGenerateItemList");
		return generate;
	}
}
	

ExpressionOperator FlattenedGenerateItem(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input, ArrayList<Boolean> flattenList): 
{
	ExpressionOperator item; 
	Schema schema = null; 
	Token t; 
	Schema.FieldSchema fs = null; 
	boolean flatten = false;
	log.trace("Entering FlattenedGenerateItem");
}
{
	(
	(
	(
		<FLATTEN> "(" item = InfixExpr(over,specs,lp,input) ")" 
		{
			flatten = true;
		}
	)
|	(item = InfixExpr(over,specs,lp,input))
|	( <STAR> 
		{
			LOProject project = new LOProject(lp, new OperatorKey(scope, getNextId()), input, -1); 
			project.setStar(true); 
			item = project;
			lp.add(project);
			log.debug("FGItem: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
		}
	)
	)
	[ <AS> (LOOKAHEAD(2) "(" schema = TupleSchema() ")" {if(schema.size() > 1) {throw new ParseException("Schema mismatch");} fs = schema.getFields().get(0);} | fs = AtomSchema() )]
	)
	{
		log.debug("item: " + item.getClass().getName());
		if(null != fs) {
			item.setFieldSchema(fs); 
		}
		flattenList.add(flatten);
		log.trace("Exiting FlattenedGenerateItem");
		return item;
	}
}
	
ExpressionOperator InfixExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator expr; 
	log.trace("Entering InFixExpr");
}
{
	expr = AdditiveExpr(over,specs,lp,input) 
	{log.trace("Exiting InFixExpr");return expr;}
}

ExpressionOperator AdditiveExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{ 
	Token t; 
	ExpressionOperator lhs, rhs, exprOp; 
	log.trace("Entering AdditiveExpr");
}
{
	(
	lhs = MultiplicativeExpr(over,specs,lp,input) 	
		(
		( t = "+" | t = "-" ) rhs = MultiplicativeExpr(over,specs,lp,input)
		 	
		{
			assertAtomic(lhs,true);
			assertAtomic(rhs,true);
			if (t.image.equals("+")){
				exprOp = new LOAdd(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
			}else{
				exprOp = new LOSubtract(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
			}
			lp.add(exprOp);
			log.debug("AdditiveExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
			lp.connect(lhs, exprOp);
			log.debug("AdditiveExpr: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + exprOp + " logical plan " + lp);
			lp.connect(rhs, exprOp);
			log.debug("AdditiveExpr: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + exprOp + " logical plan " + lp);
			lhs = exprOp;
		}
		)*
	)
	{
		log.trace("Exiting AdditiveExpr");
		return lhs;
	}		
}

ExpressionOperator MultiplicativeExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{ 
	Token t; 
	ExpressionOperator lhs, rhs, exprOp; 
	log.trace("Entering MultiplicativeExpr");
}
{
		(
		lhs = CastExpr(over,specs,lp,input)
		(
		( t = <STAR> | t = "/" | t = "%") rhs = CastExpr(over,specs,lp,input) 			
		{
			assertAtomic(lhs,true);
			assertAtomic(rhs,true);
			if (t.image.equals("*")){
				exprOp = new LOMultiply(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
			}else if (t.image.equals("/")){
				exprOp = new LODivide(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
			}else {
				exprOp = new LOMod(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
			}
			lp.add(exprOp);
			log.debug("MultiplicativeExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
			lp.connect(lhs, exprOp);
			log.debug("MultiplicativeExpr: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + exprOp + " logical plan " + lp);
			lp.connect(rhs, exprOp);
			log.debug("MultiplicativeExpr: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + exprOp + " logical plan " + lp);
			lhs = exprOp;
		}
		)*
		)
		{
			log.trace("Exiting MultiplicativeExpr");
			return lhs;
		}
}

ExpressionOperator CastExpr(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) :
{
    byte type = DataType.BYTEARRAY;
    ExpressionOperator cast;
    ExpressionOperator exprOp;
    boolean castRequired = false;
    log.trace("Entering Cast");
}
{
    [LOOKAHEAD(2)"(" type = Type() {castRequired = true;}")"] exprOp = UnaryExpr(over, specs, lp, input)
    {
        if(castRequired) {
            cast = new LOCast(lp, new OperatorKey(scope, getNextId()), exprOp, type);
            lp.add(cast);
		    log.debug("Added operator " + cast.getClass().getName() + " " + cast + " to logical plan " + lp);
            lp.connect(exprOp, cast);
		    log.debug("Connected operator " + exprOp.getClass().getName() + " " + exprOp + " to " + cast + " logical plan " + lp);
            log.trace("Exiting Cast");
            return cast;
        } else {
            log.trace("Exiting Cast");
            return exprOp;
        }
    }
}

ExpressionOperator UnaryExpr(Schema over,  Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator expr; 
	log.trace("Entering UnaryExpr");
}
{
	(
	LOOKAHEAD(BaseEvalSpec(over,specs,lp,input)) expr = BaseEvalSpec(over,specs,lp,input)
|	( "(" expr = InfixExpr(over,specs,lp,input) ")" )
|	expr = NegativeExpr(over,specs,lp,input)

	)
	{log.trace("Exiting UnaryExpr");return expr;}
}

ExpressionOperator NegativeExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ExpressionOperator c1;
	LogicalPlan exprPlan = new LogicalPlan();
	log.trace("Entering NegativeExpr");
}
{
	"-" c1=CastExpr(over,specs,lp,input)
	{
		ExpressionOperator eOp = new LONegative(lp, new OperatorKey(scope, getNextId()), c1);
		lp.add(eOp);
		log.debug("NegativeExpr: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
		lp.connect(c1, eOp);
		log.trace("Exiting NegativeExpr");
		return eOp;
	}
}

	
ExpressionOperator BaseEvalSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) :
{
	ExpressionOperator item;
	ExpressionOperator projection; 
	Schema subSchema = null; 
	Token t; 
    Object key = new Object();
	log.trace("Entering BaseEvalSpec");
}
{
	(
    LOOKAHEAD(Const(lp)) item = Const(lp)
|	(
	(
		LOOKAHEAD(FuncEvalSpec(over,specs,lp,input))
		item = FuncEvalSpec(over,specs,lp,input)
	|	item = ColOrSpec(over,specs,lp,input) 
	| 	item = BinCond(over,specs,lp,input)
	
	)
	(
		{ 
			Schema.FieldSchema fs = item.getFieldSchema(); 
			subSchema = fs.schema; 
			//TODO
			//HACK for the schema problems with LOProject
			//Check the schema to see if the constituent
			//field is a bag or a tuple/ If so, then get
			//that schema and send it out instead of the
			//actual schema
			log.debug("subSchema: " + subSchema);
			if(null != subSchema) {
				log.debug("Printing subSchema Aliases");
				subSchema.printAliases();
			}
			/*	
			log.debug("Printing the field schemas of subSchema");
			for(Schema.FieldSchema fs: subSchema.getFields()) {
				log.debug("fs: " + fs);
				subSchema = fs.schema;
			}
			*/
		}
		( 
			"." projection = BracketedSimpleProj(subSchema,lp,item) 
			{
				assertAtomic(item,false); 
				lp.remove(item);
				item = projection;
			}
		)
|		( "#" key = AtomDatum() { 
			assertAtomic(item, false);
			ExpressionOperator mapLookup = new LOMapLookup(lp, new OperatorKey(scope, getNextId()), item, key, DataType.BYTEARRAY, null);
			lp.add(mapLookup);
			log.debug("BaseEvalSpec: Added operator " + mapLookup.getClass().getName() + " " + mapLookup + " to logical plan " + lp);
			lp.connect(item, mapLookup);
			item = mapLookup;
			log.debug("BaseEvalSpec: Connected operator " + item.getClass().getName() + " " + item+ " to " + mapLookup + " logical plan " + lp);
		}
		)
	)*	
	)
	)
	{log.trace("Exiting BaseEvalSpec"); return item;}
}



ExpressionOperator BinCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	ExpressionOperator cond; 
	ExpressionOperator ifTrue, ifFalse; 
	LogicalPlan conditionPlan = new LogicalPlan();
	LogicalPlan truePlan = new LogicalPlan();
	LogicalPlan falsePlan = new LogicalPlan();
	log.trace("Entering BinCond");
}
{	
	(
	"(" cond = PCond(over,specs,lp,input) "?" ifTrue = InfixExpr(over,specs,lp,input) 
	":" ifFalse = InfixExpr(over,specs,lp,input) ")"
	
	)
	{ 
		//ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()), conditionPlan, truePlan, falsePlan);
		ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()), cond, ifTrue, ifFalse);
		//TODO - Need to connect expression operators with the new plan
		lp.add(bincond);
		log.debug("BinCond: Added operator " + bincond.getClass().getName() + " " + bincond + " to logical plan " + lp);
		lp.connect(cond, bincond);
		lp.connect(ifTrue, bincond);
		lp.connect(ifFalse, bincond);
		log.trace("Exiting BinCond");
		return bincond;
	}
}


ExpressionOperator FuncEvalSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	String funcName; 
	List<ExpressionOperator> args;
	ExpressionOperator userFunc;
	log.trace("Entering FuncEvalSpec");
}
{
	funcName=EvalFunction() "(" args=EvalArgs(over,specs,lp,input) ")" 
	{
		//check if the function name is an alias
		//if the user has defined an alias then 
		//verify if the number of of arguments match
		//and create a new LOUserFunc with the information
		//from the lookup table

		LOUserFunc userAliasFunc = (LOUserFunc)getDefineOp(funcName);

		if(null == userAliasFunc) {

			userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcName, args, DataType.BYTEARRAY);
		} else {
			//we have an alias
			int expectedNumArgs = userAliasFunc.getArguments().size();
			int numArgs = args.size();
			if(expectedNumArgs != numArgs) {
				throw new ParseException("Expected " + expectedNumArgs + " argument(s) found " + numArgs + " argument(s)");
			}
			userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), userAliasFunc.getFuncName(), userAliasFunc.getArguments(), userAliasFunc.getType());

		}
		lp.add(userFunc);
		log.debug("FuncEvalSpec: Added operator " + userFunc.getClass().getName() + " " + userFunc + " to logical plan " + lp);
		for(ExpressionOperator exprOp: args) {
			lp.connect(exprOp, userFunc);
			log.debug("FuncEvalSpec: Connected operator " + exprOp.getClass().getName() + " " + exprOp+ " to " + userFunc + " logical plan " + lp);
		}
		log.trace("Exiting FuncEvalSpec");
		return userFunc;
	}
}

List<ExpressionOperator> EvalArgs(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) : 
{
	ArrayList<ExpressionOperator> specList = new ArrayList<ExpressionOperator>(); 
	ExpressionOperator item;
	log.trace("Entering EvalArgs");
}
{
	(
	(item=EvalArgsItem(over,specs,lp,input)	{specList.add(item);}
	("," item=EvalArgsItem(over,specs,lp,input) {specList.add(item);})*)
	
	| {}
	)
	{
		log.trace("Exiting EvalArgs");
		return specList;
	}
}

ExpressionOperator EvalArgsItem(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
{
	ExpressionOperator item;
	log.trace("Entering EvalArgsItem");
}
{
	(
	item = InfixExpr(over,specs,lp,input)
|	<STAR> 
	{
		LOProject project = new LOProject(lp, new OperatorKey(scope, getNextId()), input, -1); 
		project.setStar(true); 
		item = project;
		lp.add(project);
		log.debug("EvalArgsItem: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
	}
	)
	{log.trace("Exiting EvalArgsItem");return item;}
}

ExpressionOperator FuncDeclareSpec(LogicalPlan lp) : 
{
	String funcName; 
	List<ExpressionOperator> args;
	byte type = DataType.BYTEARRAY;
	log.trace("Entering FuncDeclareSpec");
}
{
	[type = Type()] funcName=EvalFunction() "(" args=FuncDeclareArgs(lp) ")" 
	{
		ExpressionOperator userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcName, args, type);
		log.trace("Exiting FuncDeclareSpec");
		return userFunc;
	}
}

List<ExpressionOperator> FuncDeclareArgs(LogicalPlan lp) : 
{
	ArrayList<ExpressionOperator> specList = new ArrayList<ExpressionOperator>(); 
	ExpressionOperator item;
	log.trace("Entering FuncDeclareEvalArgs");
}
{
	(
	(item=FuncDeclareArgsItem(lp)	{specList.add(item);}
	("," item=FuncDeclareArgsItem(lp) {specList.add(item);})*)
	
	| {}
	)
	{
		log.trace("Exiting EvalArgs");
		return specList;
	}
}

ExpressionOperator FuncDeclareArgsItem(LogicalPlan lp):
{
	ExpressionOperator item;
	byte type = DataType.BYTEARRAY;
	Token t = null;
	log.trace("Entering FuncDeclareArgsItem");
}
{
	(
	type = Type() [t = <IDENTIFIER>]
	{
		LOProject project = new LOProject(lp, new OperatorKey(scope, getNextId()), null, -1); 
		project.setType(type);
		if(null != t) {
			project.setAlias(t.image); 
		}
		item = project;
	}
	)
	{log.trace("Exiting FuncDeclareArgsItem");return item;}
}

byte Type() : 
{ 
	log.trace("Entering Type");
	byte type;
}
{
 (type = BasicType() | type = CompositeType()) 
 {
	log.trace("Exiting Type");
 	return type;
 }	
}

byte CompositeType() : 
{ 
	log.trace("Entering CompositeType");
	Token t = null;
	byte type;
}
{
 (t = <MAP>| t = <BAG>| t = <TUPLE>) 
 {
	log.debug("t: " + t + " type: " + nameToTypeMap.get(t.image.toUpperCase()));
 	type = nameToTypeMap.get(t.image.toUpperCase());
	log.trace("Exiting CompositeType");
 	return type;
 }
}

byte BasicType() : 
{ 
	log.trace("Entering BasicType");
	Token t = null;
	byte type;
}
{
 (t = <INT>| t = <LONG>| t = <FLOAT>| t = <DOUBLE>| t = <CHARARRAY>| t = <BYTEARRAY>) 
 {
    String typeName = t.image;
	log.debug(" nameToTypeMap: " + nameToTypeMap);
	log.debug("t: " + t + " type: " + nameToTypeMap.get(typeName.toUpperCase()));
    if(typeName.equalsIgnoreCase("int")) {
        typeName = "integer";
    }
 	type = nameToTypeMap.get(typeName.toUpperCase());
	log.trace("Exiting BasicType");
 	return type;
 }
}

Schema.FieldSchema FieldSchema() : 
{
	Token t1; 
	Schema item = null; 
	Schema.FieldSchema fs = null; 
	log.trace("Entering FieldSchema");
}
{
	(
	LOOKAHEAD(SchemaTuple()) fs = SchemaTuple()
|	LOOKAHEAD(SchemaBag()) fs = SchemaBag()
|	LOOKAHEAD(SchemaMap()) fs = SchemaMap()
|	LOOKAHEAD(AtomSchema()) fs = AtomSchema()
	)
	//{log.debug("Printing Aliases"); item.printAliases();log.trace("Exiting Schema");return item;}
	{log.trace("Exiting FieldSchema");return fs;}
}

Schema.FieldSchema AtomSchema() : 
{
	Token t1 = null;
	byte type = DataType.BYTEARRAY;
	Schema.FieldSchema fs;
	log.trace("Entering AtomSchema");
}
{
	(  ( t1 = <IDENTIFIER> [":" type = BasicType() ] )
		{ 
			if(null != t1) {
				log.debug("AtomSchema: " + t1.image);
				fs = new Schema.FieldSchema(t1.image, type); 
			} else {
				fs = new Schema.FieldSchema(null, type); 
			}
			
			log.trace("Exiting AtomSchema");
			return fs;
		} 
	)
}

Schema.FieldSchema SchemaMap() :
{
	Token t1 = null; 
	Schema.FieldSchema fs;
	log.trace("Entering SchemaMap");
}
{
	( t1 = <IDENTIFIER> )  [":" <MAP>] "[" "]"
	{
		if (null != t1) {
			log.debug("MAP alias " + t1.image);
			fs = new Schema.FieldSchema(t1.image, DataType.MAP);
		} else {
			fs = new Schema.FieldSchema(null, DataType.MAP);
		}
		log.trace("Exiting SchemaMap");
		return fs;
	} 
}

Schema.FieldSchema SchemaTuple() : 
{
	Token t1 = null; 
	Schema s;
	Schema.FieldSchema fs;
	log.trace("Entering SchemaTuple");
}
{ 
	( t1 = <IDENTIFIER> )  [":" <TUPLE>] "(" s = TupleSchema() ")" 
	{
		if (null != t1) {
			log.debug("TUPLE alias " + t1.image);
			fs = new Schema.FieldSchema(t1.image, s, DataType.TUPLE);
		} else {
			fs = new Schema.FieldSchema(null, s, DataType.TUPLE);
		}
		log.trace("Exiting SchemaTuple");
		return fs;
	} 
}

Schema.FieldSchema SchemaBag() : 
{
	Token t1 = null; 
	Schema s;
	Schema.FieldSchema fs;
	log.trace("Entering SchemaBag");
}
{ 
	( t1 = <IDENTIFIER> ) [":" <BAG>] "{" (fs = SchemaTuple() | {} {fs = new Schema.FieldSchema(null, new Schema());}) "}" 
	{
        s = new Schema(fs);
		if (null != t1) {
			log.debug("BAG alias " + t1.image);
			fs = new Schema.FieldSchema(t1.image, s, DataType.BAG);
		} else {
			fs = new Schema.FieldSchema(null, s, DataType.BAG);
		}
		log.trace("Exiting SchemaBag");
		return fs;
	} 
}


Schema TupleSchema() : 
{
	Schema item = null; 
	Schema list = new Schema(); 
	Schema.FieldSchema fs = null;
	log.trace("Entering TupleSchema");
}
{
	(	
	(	
		fs = FieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);} 
		( "," fs = FieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);})* 
	)
|		{}
	)
	{log.debug("Printing Aliases in TupleSchema"); list.printAliases();log.trace("Exiting TupleSchema");return list;}
}


// These the simple non-terminals that are shared across many

String EvalFunction() : 
{
	String funcName;
	log.trace("Entering EvalFunction");
}
{
	funcName = QualifiedFunction()
	{
		ExpressionOperator userFunc = getDefineOp(funcName);
		if(null == userFunc) {
		//TODO
		//Commented out the code for instaniateFunc as it's failing
			try{
				EvalFunc ef = (EvalFunc) pigContext.instantiateFuncFromAlias(funcName);
			}catch (Exception e){
				throw new ParseException(e.getMessage());
			}
		}
		log.trace("Exiting EvalFunction");
		
		return funcName;
	}
}

/**
 * Bug 831620 - '$' support
 */
void ClassName() #void : {} { <IDENTIFIER> (("."  <IDENTIFIER>)|("$"  <IDENTIFIER>))* }

/**
 * Bug 831620 - '$' support
 */
String QualifiedFunction() #void : {Token t1;StringBuffer s=new StringBuffer(); log.trace("Entering QualifiedFunction");}
{
	((t1=<IDENTIFIER> { s.append(t1.image);}
	 (("." t1=<IDENTIFIER> {s.append("." + t1.image);})| 
	  ("$" t1=<IDENTIFIER> {s.append("$" + t1.image);}))*)) 
	 {
	 	log.debug("QualifiedFunction: " + s.toString());
	 	log.trace("Exiting QualifiedFunction"); 
	 	return s.toString();
	 }
}


// If there is one time it may not be bracketed, but if multiple, they must be bracketed
ExpressionOperator BracketedSimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp) : 
{
	ExpressionOperator es; 
	int i; 
	ExpressionOperator spec = null;
	log.trace("Entering BracketedSimpleProj");
	log.debug("eOp: " + eOp.getClass().getName());
}
{
	(
	spec = ColOrSpec(over,null,lp,eOp) 
|	("(" spec = SimpleProj(over,lp,eOp) ")")	
	
	)
	{log.trace("Exiting BracketedSimpleProj");return spec;}	
}

ExpressionOperator SimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp): 
{
	int i; 
	ArrayList<Integer> colList = new ArrayList<Integer>();
	log.trace("Entering SimpleProj");
}
{
	i = ColName(over) {colList.add(i);}	
		("," i = ColName(over) {colList.add(i);})*
	{
		ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, colList);
		lp.add(project);
		log.debug("SimpleProj: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
		log.trace("Exiting SimpleProj");
		return project;
	}
}

DataBag Bag() :
{
	byte type = DataType.BYTEARRAY;
	BagFactory bagFactory = BagFactory.getInstance();
    DataBag bag = bagFactory.newDefaultBag();
    Tuple t = null;
    log.trace("Entering bag");
}
{
 ("(" t = Tuple() {bag.add(t);} ")" ("," "(" t = Tuple() {bag.add(t);} ")" )* )
 {
    log.trace("Exiting bag");
    return bag;
 }
}

Tuple Tuple() : 
{
	byte type = DataType.BYTEARRAY;
	Object obj = null;
	TupleFactory tupleFactory = TupleFactory.getInstance();
	ArrayList<Object> objList = new ArrayList<Object>(); 
	log.trace("Entering Tuple");
}
{
	(	
	(	
            (
                obj = Datum() {log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);} 
		        ( LOOKAHEAD(2) "," obj = Datum() {log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);})* 
            )
            |		{}
	)
	)
	{
		Tuple tuple = tupleFactory.newTuple(objList);
		log.trace("Exiting Tuple");
		return tuple;
	}
}

Map<Object, Object> Map() :
{
	Map<Object, Object> keyValues = new HashMap<Object, Object>();
	log.trace("Entering Map");
	
}
{
	( KeyValuePair(keyValues) ("," KeyValuePair(keyValues))* )
	{
		log.trace("Exiting Map");
		return keyValues;
	}
}

void KeyValuePair(Map<Object, Object> keyValues) :
{
	Object key = null;
	Object value = null;
	log.trace("Entering KeyValuePair");
}
{
	(key = AtomDatum() "#" value = Datum())
	{
		keyValues.put(key, value);
		log.trace("Exiting KeyValuePair");
	}
	
}

Object AtomDatum():
{
    Object obj = null;
	Token t;
	log.trace("Entering AtomDatum");
}
{
	(
	t = <INTEGER> {obj = new Integer(Integer.parseInt(t.image));}
|	t = <LONGINTEGER> 
    {
        String num = t.image.substring(0, t.image.length() - 2);
        obj = new Long(Long.parseLong(num));
    }
|	t = <FLOATNUMBER> {obj = new Float(Float.parseFloat(t.image));}
|	t = <DOUBLENUMBER> {obj = new Double(Double.parseDouble(t.image));}
|	t = <QUOTEDSTRING> {obj = unquote(t.image);}
	)
	{
        log.debug("Number: " + t.image + " obj type: " + DataType.findTypeName(DataType.findType(obj)));
		log.trace("Exiting AtomDatum");
		return obj;
	}
}

Object Datum(): 
{
    Object obj = null;
	log.trace("Entering Datum");
}
{
	(
	obj = "[" Map() "]"
|	obj = "{" Bag() "}"
|	obj = "(" Tuple() ")"
|	obj = AtomDatum()
	)
	{
		log.trace("Exiting Datum");
		return obj;
	}
}

ExpressionOperator Const(LogicalPlan lp) : 
{
	Token t1; 
	String s;
	Object obj = null;
	byte type = DataType.BYTEARRAY;
	log.trace("Entering Const");
}
{
	(
	LOOKAHEAD(AtomDatum()) obj = AtomDatum ()
|	obj= Datum()
	)
	{
		ExpressionOperator lConst = new LOConst(lp, new OperatorKey(scope, getNextId()), obj);
        type = DataType.findType(obj);
        log.debug("type: " + DataType.findTypeName(type));
		lConst.setType(type);
		lp.add(lConst);
		log.debug("Const: Added operator " + lConst.getClass().getName() + " " + lConst + " to logical plan " + lp);
		log.trace("Exiting Const");
		return lConst;
	}
}

ExpressionOperator ColOrSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) : 
{
	ExpressionOperator spec;
	log.trace("Entering ColOrSpec");
}
{
	(
	spec = DollarVar(lp, eOp)
|	spec = AliasFieldOrSpec(over,specs,lp,eOp)

	)
	{
		log.trace("Exiting ColOrSpec");
		return spec;
	}
}

ExpressionOperator DollarVar(LogicalPlan lp, LogicalOperator eOp) : 
{
	Token t1;
	log.trace("Entering DollarVar");
}
{
	t1=<DOLLARVAR>	
	{
		log.debug("Token: " + t1.image);
		ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, undollar(t1.image));
		try {
			log.debug("eOp: " + eOp.getClass().getName() + " " + eOp);
			lp.add(project);
			log.debug("DollarVar: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
		} catch (Exception planException) {
			ParseException parseException = new ParseException(planException.getMessage());
			throw parseException;
		}
		log.trace("Exiting DollarVar");
		return project;
	}
}

ExpressionOperator AliasFieldOrSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) : 
{
	Token t1;
	LogicalPlan projectInputPlan = new LogicalPlan();
	log.trace("Entering AliasFieldOrSpec");
}
{
	(t1=<GROUP> | t1=<IDENTIFIER>) 
	{	
		log.debug("Token: " + t1.image);
		if(null != eOp) log.debug("eOp: " + eOp.getClass().getName());
		int i; 
		ExpressionOperator item = null;
		if (specs!=null) {
			log.debug("specs != null");
			LogicalOperator op = specs.get(t1.image);
			if(null != op) {
				log.debug("Alias: " + op.getAlias());
				
				item = new LOProject(lp, new OperatorKey(scope, getNextId()), op, -1);
				((LOProject)item).setStar(true);
				log.debug("Set star to true");
				item.setAlias(t1.image);
				
				if(insideGenerate()) {
					log.debug("AliasFieldOrSpec: Inside generate");
					addGenerateInput(op);
				}
				try {
					lp.add(item);
					log.debug("AliasFieldOrSpec: Added operator " + item.getClass().getName() + " " + item + " to logical plan " + lp);
				} catch (Exception planException) {
					ParseException parseException = new ParseException(planException.getMessage());
					throw parseException;
				}
			}
		}
		
		if (item == null){
			log.debug("item == null");
			if (null == over) log.debug("over is null");
			if ( over == null ||  (i = over.getPosition(t1.image)) == -1) {
				log.debug("Invalid alias: " + t1.image + " in " + over);
				if(null != over) {
					log.debug("Printing out the aliases in the schema");
					over.printAliases();
				}
				throw new ParseException("Invalid alias: " + t1.image + " in " + over);
			}
			log.debug("Position of " + t1.image + " = " + i);
			if(null != over) {
				log.debug("Printing out the aliases in the schema");
				over.printAliases();
			}	
			item = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, i);
			item.setAlias(t1.image);
			try {
				lp.add(item);
				log.debug("AliasFieldOrSpec: Added operator " + item.getClass().getName() + " " + item + " to logical plan " + lp);
			} catch (Exception planException) {
				ParseException parseException = new ParseException(planException.getMessage());
				throw parseException;
			}
		}
		
		log.trace("Exiting AliasFieldOrSpec");
		return item;
	}
}
